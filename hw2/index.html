<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 2 Write-Up</h1>
		<div style="text-align: center;">Names: </div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-hgonzalez8/">cal-cs184-student.github.io/hw-webpages-hgonzalez8/</a>

		<br>
		
		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/hw-webpages-hgonzalez8">github.com/cal-cs184-student/hw-webpages-hgonzalez8</a>

		<figure>
			<img src="teapot.png" alt="Teapot" style="width:50%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Section I: Bezier Curves and Surfaces</h2>

		<h3>Part 1: Bezier curves with 1D de Casteljau subdivision</h3>
		De Casteljau's Algorithm uses the divide and conquer method to evaluate Bezier curves. It uses subdivision to separate the curve into multiple sections using the control points as the starting point. 
		Linear interpolation is used on each pair of control points to compute an intermediate control point on the line connecting the two original control points. The steps I used to implement de Casteljau's algorithm are as follows.
		For each level/step in the algorithm we: 
		1. Check the size of the vector: Since linear interpolation requires two points, we need to double check that the vector we have has two or more points to be able to compute the intermediate point.
		2. Create a new vector object to store the new points: If there are enough points to work with, we will be able to do the calculations, so we need to have a place to store the new values.
		3. Go through the elements in the vector: Since each computation requires point i and point i+1, we only loop through the vector starting from 0 until the second to last vector.
			3a. Use the equation for linear interpolation: \( lerp = point<sub>i</sub> * (1-t) + point<sub>i+1</sub> * t \)
			3b. Store the new point into the vector we created: As we calculate these values, we want to store them in the same object to keep them together
		4. Return the vector with intermediate control points: Once we have finished the linear interpolation for all pairs of points in the vector, we return the vector that has all the intermediate control points that will be used in the next level/step.
		These steps are done recursively until there is only one point left, which is the point on the curve.

		<p>Here is an example 2x2 gridlike structure using an HTML table. Each <b>tr</b> is a row and each <b>td</b> is a column in that row. You might find this useful for framing and showing your result images in an organized fashion.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="hw2_step0.png" width="400px"/>
				  <figcaption>Original Curve and Control Points</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="hw2_step1.png" width="400px"/>
				  <figcaption>Step 1</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="hw2_step2.png" width="400px"/>
				  <figcaption>Step 2</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="hw2_step3.png" width="400px"/>
				  <figcaption>Step 3</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="hw2_step4.png" width="400px"/>
				  <figcaption>Step 4</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="hw2_step5.png" width="400px"/>
				  <figcaption>Step 5: Final Point on Curve</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="hw2_diff_curve_diff_t.png" width="400px"/>
				  <figcaption>Different Curve and Different Parameter</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="hw2_even_more_diff.png" width="400px"/>
				  <figcaption>Different Curve and Different Parameter</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="hw2_more_diff_t.png" width="400px"/>
				  <figcaption>Original Curve and Different Parameter</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h3>Part 2: Bezier surfaces with separable 1D de Casteljau</h3>
		The method that is used to evaluate Bezier surfaces are to use two stages of De Casteljau's algorithm (applying it twice) in a row. The algorithm allows us to evaluate a point on a Bezier surface patch by using two different directions that have different parameters (u,v). This reduces the surface which is 2D into a sequence of curve evaluations which are 1D. 
		Since the surface control points are in an n x n grid, there are two directions that the de Castelijau's algorithm for curves is applied to. I had to call the algorithm with two different parameters: 
		u -- for each row vector: The algorithm is called for each row vector, so it gets compressed into a point
		v -- for each column vector: The algorithm is called for each column vector as well, so the size of the columns need to be checked
		I used the following steps to implement the algorithm for a surface:
		1. Check the size of the vector of vectors: Just like before, since we are still using linear interpolation, we need more than one column to be able to do the computation in the second stage.
		2. Create a new vector: This vector with contain the new points that will be evaluated for each row
		3. Call the evaluation function on each row using u as the parameter: Each row is treated as control points for a curve, so we compute a point for each row
		4. Call the evaluation function on the column using v as the parameter: Since each row is a vector, once they are all evaluated, we are left with one column that forms a vector. We then evaluate that vector using the points that were derived before as our control points.

		<figure>
			<img src="hw2_part2.png" alt="Teapot" style="width:90%"/>
			<figcaption>Teapot</figcaption>
		</figure>

		<h2>Section II: Triangle Meshes and Half-Edge Data Structure</h2>

		<h3>Part 3: Area-weighted vertex normals</h3>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h3>Part 4: Edge flip</h3>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h3>Part 5: Edge split</h3>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h3>Part 6: Loop subdivision for mesh upsampling</h3>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>(Optional) Section III: Potential Extra Credit - Art Competition: Model something Creative</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>